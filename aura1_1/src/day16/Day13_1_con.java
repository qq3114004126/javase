package day16;

import java.util.Arrays;

/*
 * 第二十章   集合
 * 一. 数据结构基本知识
 * 二. 集合 
 * 
 * 一、数据结构基本知识
 * (一)基本数据结构
 * 数据结构：
 * 数据： 计算机中存储的元素
 * 结构：数据与数据之间的 关系
 * 常用的数据和数据之间的关系：点状、线性、树状、网状....
 * 
 * 数据结构包括两个层次（角度）
 * （1）逻辑结构：数据元素之间存在的逻辑关系
 *            包含四种结构：线性结构、树型结构、图状结构、集合结构
 * （2）物理结构：数据在计算机中真实的存储结构
 *            包含两种：顺序存储和链式存储(在内存片上，一个是连续存储，一个是不连续存储)
 * 
 * 
 * 常用的几种数据结构：
 * （1）数组（一维线性存储）物理角度   一维顺序线性表
 * （2）链表
 * （3）堆栈
 * （4）队列
 * （5）树
 * （6）哈希表
 *  其中数组、链表、堆栈、队列-----逻辑结构上是线性存储
 *  堆栈、队列：受限的线性存储。
 *  
 *  特殊说明：
 *  其他的有些资料，会把常用的数据结构：分为线性表（顺序线性表、线性链表）... 、数组概念升级成为特殊的线性表（一维度、多维度）
 *  角度不同：
 *  数组：（从物理结构结构角度）
 *  线性表：（从逻辑的结构角度）
 *  顺序线性表：数组（一维数组）+线性表
 *  
 *  
 *  
 *  1. 数组
 *  从物理结构上划分的数组。不是java中的数组。
 *  【定义】 使用一组地址连续的存储单元，依次存储线性表的数据元素。
 *  【数组中元素的访问】
 *  每个元素所占用的空间是一样的size大小。
 *  首地址+偏移量（n*size）
 *  对于每个元素访问时候的效率都是一样的。O(1) 常数时间复杂度
 *  【增加元素、删除元素】效率低，需要移动其他元素
 *  
 *  
 *  【使用场景】
 *  （1）java中的数组使用数据结构中结构中的静态数组。一组地址连续的存储单元.
 *   思考 为什么java中的数组一旦初始化了，就不能修改长度
 *   先申请了一片存，要存储十个  最后一个元素length属性
 *   原因：如果扩充了java中数组的大小，无法断定连续地址的后面有没有内存空间，如果没有空间，接着其他的数组进行存储，那么
 *       java的数组变成非连续的存储，无法访问。
 *  （2）数据结构中“动态数组”
 *  动态数组：可以进行扩容。也是在原来的静态数组的基础上形成。代价：效率慢
 *  List<T> list=new ArrayList();  就是使用动态数组 来存储
 *  
 *  java中的数组，数组的优点：快。
 *  java中的集合ArrayList，缺点：比数组慢。
 *  
 *  
 *  2. 链表
 *  一个元素“挨着”另外一个元素，不是非要连续存储。
 *  【定义】是线性（数据和数据之间的关系），但是不是连续存储。
 *  链表中的节点可以分成两个部分：
 *     数据域：存储数据
 *     指针域: 下一个元素的地址
 *  随机访问性：没有数组好，访问每个元素的效率不同   时间复杂O（n）
 *  对于元素进行插入和删除效率比数组高：只需要修改指针域即可。
 *  
 *  大多数的存储都是优先选择数组结构。
 *  
 *  【了解】 链表：单向链表和双向链表。
 *  双向链表：一定程度上优化了单向链表的访问性，但是增加了添加元素、删除元素的复杂度。
 *  
 *  3. 堆栈
 *  栈 ：线性存储（元素和元素之间有关系），受限的线性表
 *  栈顶(表尾)：口（出入口）
 *  栈底(表头)：第一个进入的元素所放的位置
 *  规则：后进先出、先进后出。 LIFO  
 *  
 *  【使用场合】
 *  方法的调用
 *    A--B--C---D  --E  目的为了接住返回值
 *  异常的向上传播
 *     异常抛出给调用者
 *     
 *  4. 队列
 *  队列：线性存储（为了表达元素和元素之间的关系），受限的线性表
 *  队头（表头）：第一个进入的元素  （出）
 *  队尾（表尾）：后一个进入的元素（入）
 *  规则：先进先出   FIFO
 *  【场合】 处理多线程。
 *  
 *  【了解】 也可以有双端队列。可以进行队头和队尾的添加和删除元素。可以实现栈的存储
 *  缺点：添加和删除元素
 *  
 *  5.树
 *  结点集合连接每对结点的有向边集组成。
 *  二叉树：特征每个节点（除叶子节点以外）都只有不超过两个节点。（0个，1个 2个）
 *  满二叉树：除叶子节点以外，每个 节点都有两个子节点。
 *       对满二叉树进行编号：从上到下，从左到右
 *  完全二叉树：当一个二叉树的所有节点编号，都跟满二叉树保持一致，称为完全二叉树。
 *  
 *  遍历树：对树中的所有节点进行访问。
 *  广度遍历：按照层次遍历，先爷爷   找父辈或者父类兄弟
 *  深度遍历：爷爷--父亲--儿子
 *  
 *  掌握的内容：对于二叉树的遍历：
 *  针对于“根节点”---不仅仅是最根级别的节点
 *  先序遍历：先根，左，右
 *  中序遍历：先左，根，右
 *  后序遍历：先左，右，根
 *  
 *  
 *  6.哈希表
 *  希望将一组数据存储到内存中一组有序的存储单元中（不是按照一对一的存储）
 *  存储规则：按照哈希规则进行存储。
 *  数学中的规则  y=f（x）  哈希函数的规则
 *  
 *  假如：y=x%7  一定会将众多的x存储到7个数据单元中。
 *  x   y
 *  0   0
 *  1   1
 *  2   2
 *  3   3
 *  ......
 *  7   0  
 *  8   1
 *  9   2
 *  [好处] 当我们访问元素的时候，都可以是常数时间复杂度
 *  【问题】 都会采用hashcode中扩展，两种方法，重新计算hashcode，存入下一个地址
 *         也可以对单一地址进行扩展 ，扩展成新的数组
 *  将一组关键字（数据）根据哈希函数（规则），映射到一个有限的地址集上，这种结构的表称为hash表。
 *  【场合】
 *  java中的map : key value
 *  
 *  
 *  （二）查找和排序
 *  查找：准确的说查找方法有三种：顺序查找；二分查找；分块查找（了解）
 *  排序：冒泡、选择、插入、希尔排序、快速、归并
 */

//插入排序
//【规则】：从第二个元素开始，插入到现有的已排好序的数组中，保证前小后大的排序
//希尔排序
//【规则】：改进版的插入排序（最小增量排序）分组
//增量：inc  将i个元素和i+inc、i+2*inc 、i+3*inc.....
// 每次进行分组，对每一组的元素进行（插入）排序，注意的是，每个元素的原来位置保持不变
//增量设置的规则：没有  原则：从大到小   每次取一半  6  3   1
//假设增量为3  2  1
public class Day13_1_con {
//	希尔排序
	public  static void shell(int[] t,int []increment){
		//int[] t={3,-2,5,10,-9,11,7,-1};
		for (int inc : increment) {
//			每一个增量下的每一组
			for(int k=0;k<inc;k++){
				for(int i=k+inc;i<t.length;i+=inc){
					int temp=t[i];
					int j= i-inc;  
					while(j>=0&&temp<t[j]){
						t[j+inc]=t[j];     
						j-=inc;
					}
					t[j+inc]=temp;
					System.out.println(Arrays.toString(t));
				}
			}
		}
	
		
	}
	
//	插入排序
 	public static void insert(int []t){
		//int[] t={3,-2,5,10,-9,11,7,-1};
		//int[] t={-2,3,5,10,-9,11,7,-1};
		//int[] t={-9,-2,3,5,10,11,7,-1};
		//int[] t={-9,-2,3,5,j+1,10,11,-1};  temp=7
		for(int i=1;i<t.length;i++){
//			int i=1;   //没有排好对的第一个元素（正在排序的元素）
			int temp=t[i];//正在排序的元素值
			int j= i-1;  //排好队的最后一个元素
			while(j>=0&&temp<t[j]){
				t[j+1]=t[j];
		     		j--;
			}
			t[j+1]=temp;
		}
		
	}
	
	
//	每次都找到最小的元素，放在前面（注意：每次找到最小值的索引，再跟当前元素交换位置）
	public static void choose(int []t){
		for(int i=0;i<t.length-1;i++){
			int min_index=i;
			for(int j=i+1;j<t.length;j++){
				if (t[min_index]>t[j]){
					min_index=j;
				}
			}
			int temp=t[i];
			t[i]=t[min_index];
			t[min_index]=temp;
		}
	}
	
//	相邻的两个元素之间进行比较，如果不符合前小后大的的原则，交换
	public static void bubble(int []t){
		boolean tag=true;
		for (int j=0;j<t.length-1;j++){
			for(int i=0;i<t.length-1-j;i++){
				if(t[i]>t[i+1]){
					int temp=t[i];
					t[i]=t[i+1];
					t[i+1]=temp;
					tag=false;
				}
			}
	        if(tag){
	        	break;
	        }
		}
	}
	
	public static void binarySearch(int[] t,int key){
		Arrays.sort(t);
		int start=0;
		int end=t.length-1;
		boolean tag=true;
		while(start<=end){
			int mid=(start+end)/2;
			if(key==t[mid]){
				System.out.println("找到了");
				tag=false;
				break;
			}else if(key<t[mid]){
				end=mid-1;
			}else{
				start=mid+1;
			}
		}
		if(tag){
			System.out.println("不存在");
		}
	}
    public static void main(String[] args) {
		int[] t={3,-2,5,10,-9,11,7,-1};
//		binarySearch(t,30);
//		bubble(t);
//		insert(t);
//		choose(t);
		shell(t,new int[]{3,2,1});
		System.out.println(Arrays.toString(t));
		
	}
}
